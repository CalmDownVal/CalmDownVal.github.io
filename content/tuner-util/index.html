<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="description" content="Tuner utility with MIDI, note and frequency conversion.">
		<meta name="keywords" content="midi,frequency,note,music,production">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
		<meta name="author" content="@CalmDownVal">
		<title>
			Tuner Utility
		</title>
		<style media="screen">

@import url('https://fonts.googleapis.com/css2?family=Raleway:wght@400&display=swap');

* {
	padding: 0;
	margin: 0;
	font: inherit;
	color: inherit;
	cursor: inherit;
}

html {
	-webkit-text-size-adjust: 100%;
}

body {
	font-family: 'Raleway', sans-serif;
	font-weight: 400;
	user-select: none;
	background: #32322c;
	color: #fff;
	cursor: default;
}

a {
	cursor: pointer;
	text-decoration: underline;
}

.layout {
	position: fixed;
	inset: 0;
	display: flex;
	flex-direction: column;
	align-items: stretch;
	align-content: flex-start;
	gap: 1rem;
	padding: 2rem 1rem;
	overflow-y: auto;
	background: linear-gradient(350deg, #282823, #48483f);
}

.control-panel {
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 1rem;
	margin: 0 0 2rem 0;
}

.page-footer {
	box-sizing: border-box;
	margin: 2rem 0 0 0;
	text-align: center;
	color: rgba(255, 255, 255, .7);
}

@property --fx-offset-x {
	syntax: '<percentage>';
	initial-value: 50%;
	inherits: false;
}

@property --fx-offset-y {
	syntax: '<percentage>';
	initial-value: 50%;
	inherits: false;
}

@property --fx-opacity {
	syntax: '<number>';
	initial-value: 1;
	inherits: false;
}

.fx-shiny {
	--color: hsl(0, 75%, 63%);
	--color-light: hsl(0, 76%, 72%);
	--color-dark: hsl(0, 58%, 57%);

	box-sizing: border-box;
	display: block;
	box-shadow: 0 5px 15px rgba(0, 0, 0, .3);
	border: 2px solid transparent;
	outline: none;
	cursor: pointer;
	color: #000;
	background:
		radial-gradient(circle at var(--fx-offset-x) var(--fx-offset-y), rgba(255, 255, 255, .2), rgba(255, 255, 255, 0)) no-repeat 0% 0% / 100% 100% border-box,
		linear-gradient(350deg, var(--color-dark), var(--color-light)) no-repeat 0% 0% / 100% 100% padding-box,
		radial-gradient(circle at var(--fx-offset-x) var(--fx-offset-y), rgba(255, 255, 255, var(--fx-opacity)), rgba(255, 255, 255, 0)) no-repeat 0% 0% / 100% 100% border-box,
		linear-gradient(350deg, var(--color-dark), var(--color-light)) no-repeat 0% 0% / 100% 100% border-box;
	transition:
		box-shadow 3s linear,
		--fx-opacity 2s linear;
}

.fx-shiny:focus-within,
.button.button--active {
	--fx-opacity: 0;
	z-index: 200;
	box-shadow: 0 0 60px 5px var(--color);
	transition:
		box-shadow .3s linear,
		--fx-opacity .3s linear;
}

.button {
	display: flex;
	align-items: center;
	justify-content: center;
	width: 4rem;
	height: 4rem;
	border-radius: 100%;
}

.input-wrapper {
	flex-basis: 30%;
	position: relative;
	z-index: 100;
	min-height: 10rem;
	max-height: 10rem;
	border-radius: .3rem;
}

.input-wrapper:has(.input-wrapper__input:disabled) {
	cursor: no-drop;
}

.input-wrapper__header,
.input-wrapper__error {
	position: absolute;
	inset: 2rem 0 auto 2rem;
	font-size: 1.2rem;
}

.input-wrapper__error {
	text-shadow:
		0 0 16px #f25f5c,
		0 0 12px #f25f5c,
		0 0 8px #f25f5c;
}

.input-wrapper__error ~ .input-wrapper__header {
	display: none;
}

.input-wrapper__input {
	position: absolute;
	inset: auto 2rem 2rem 0;
	border: none;
	padding: 0;
	width: auto;
	outline: none;
	font-size: 3rem;
	text-align: right;
	background: transparent;
}

.input-wrapper__input::selection {
	background: rgba(255, 255, 255, .5);
}

#midi-box {
	--color: hsl(206, 100%, 58%);
	--color-light: hsl(206, 100%, 66%);
	--color-dark: hsl(206, 100%, 46%);
}

#note-box {
	--color: hsl(168, 100%, 48%);
	--color-light: hsl(168, 100%, 56%);
	--color-dark: hsl(168, 100%, 36%);
}

#freq-box {
	--color: hsl(48, 100%, 70%);
	--color-light: hsl(48, 100%, 76%);
	--color-dark: hsl(48, 100%, 56%);
}

.canvas-wrapper {
	overflow: hidden;
}

#tune-chart {
	position: absolute;
	inset: auto 2rem 0 2rem;
	height: 2rem;
	-webkit-mask: linear-gradient(black, transparent);
	        mask: linear-gradient(black, transparent);
}

#bin-chart {
	-webkit-mask: linear-gradient(transparent 0%, black 30%, black 70%, transparent 100%);
	        mask: linear-gradient(transparent 0%, black 30%, black 70%, transparent 100%);
}

.bin-chart-layout {
	width: 3rem;
	height: 2.5rem;
}

@media (min-width: 600px) {
	.layout {
		flex-flow: row wrap;
		align-content: center;
		justify-content: center;
	}

	.span-full {
		flex-basis: 100%;
	}

	.input-wrapper {
		max-width: 20rem;
	}
}

@media (min-width: 600px) and (max-width: 800px) {
	.input-wrapper__input {
		right: 1rem;
	}
}

		</style>
	</head>
	<body>
		<section class="layout">
			<div class="control-panel span-full">
				<div class="bin-chart-layout canvas-wrapper" id="bin-chart">
					<canvas></canvas>
				</div>
				<button class="button fx-shiny" id="record-button">
					<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 -960 960 960">
						<path d="M480-400q-50 0-85-35t-35-85v-240q0-50 35-85t85-35q50 0 85 35t35 85v240q0 50-35 85t-85 35Zm0-240Zm-40 520v-123q-104-14-172-93t-68-184h80q0 83 58.5 141.5T480-320q83 0 141.5-58.5T680-520h80q0 105-68 184t-172 93v123h-80Zm40-360q17 0 28.5-11.5T520-520v-240q0-17-11.5-28.5T480-800q-17 0-28.5 11.5T440-760v240q0 17 11.5 28.5T480-480Z"/>
					</svg>
				</button>
				<button class="button fx-shiny" id="ping-button">
					<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 -960 960 960">
						<path d="M640-440v-80h160v80H640Zm48 280-128-96 48-64 128 96-48 64Zm-80-480-48-64 128-96 48 64-128 96ZM120-360v-240h160l200-200v640L280-360H120Zm280-246-86 86H200v80h114l86 86v-252ZM300-480Z"/>
					</svg>
				</button>
				<div class="bin-chart-layout"></div>
			</div>
			<label class="input-wrapper fx-shiny" id="midi-box">
				<h2 class="input-wrapper__header">
					MIDI
				</h2>
				<input type="text" class="input-wrapper__input" id="midi-input" value="69" maxlength="3" inputMode="decimal">
			</label>
			<label class="input-wrapper fx-shiny" id="note-box">
				<h2 class="input-wrapper__header">
					note
				</h2>
				<input type="text" class="input-wrapper__input" id="note-input" value="A5" maxlength="3">
			</label>
			<label class="input-wrapper fx-shiny" id="freq-box">
				<h2 class="input-wrapper__header">
					frequency
				</h2>
				<input type="text" class="input-wrapper__input" id="freq-input" value="440" maxlength="8" inputMode="decimal">
				<div class="canvas-wrapper" id="tune-chart">
					<canvas></canvas>
				</div>
			</label>
			<footer class="page-footer span-full">
				Tuner Utility
				&bull;
				by <a href="https://twitter.com/CalmDownVal" target="_blank">@CalmDownVal</a>
				&bull;
				2023
			</footer>
		</section>
	</body>
	<script>

const Convert = (() => {
	const DEFAULT_TUNING = 440.0;
	const RE_NOTE = /^([a-g]#?)(\d+)$/i;
	const NOTE = {
		'a':   9, 'A':   9,
		'a#': 10, 'A#': 10,
		'b':  11, 'B':  11,
		'c':   0, 'C':   0,
		'c#':  1, 'C#':  1,
		'd':   2, 'D':   2,
		'd#':  3, 'D#':  3,
		'e':   4, 'E':   4,
		'f':   5, 'F':   5,
		'f#':  6, 'F#':  6,
		'g':   7, 'G':   7,
		'g#':  8, 'G#':  8
	};
	const ETON = [
		'C', 'C#', 'D', 'D#',
		'E', 'F', 'F#', 'G',
		'G#', 'A', 'A#', 'B'
	];

	return {
		noteToMidi(note) {
			const match = RE_NOTE.exec(note);
			if (!(match && Object.hasOwn(NOTE, match[1]))) {
				throw new Error('invalid note name');
			}

			return 12 + Math.trunc(Number(match[2]) * 12) + NOTE[match[1]];
		},
		frequencyToMidi(freq, tuning = DEFAULT_TUNING) {
			return 12 * Math.log(freq / tuning) / Math.LN2 + 69;
		},
		midiToNote(midi) {
			return ETON[midi % 12] + Math.floor(midi / 12 - 1);
		},
		midiToFrequency(midi, tuning = DEFAULT_TUNING) {
			return Math.round(100.0 * Math.pow(2.0, (midi - 69) / 12.0) * tuning) / 100.0;
		}
	};
})();

class Ping {
	#ctx;
	#osc;
	#amp;

	constructor(ctx, osc, amp) {
		this.#ctx = ctx;
		this.#osc = osc;
		this.#amp = amp;
	}

	destroy() {
		this.#ctx?.close();
	}

	emit(freq) {
		const t = this.#ctx.currentTime;
		this.#osc.frequency.setValueAtTime(freq, t);
		this.#amp.gain.cancelScheduledValues(t);
		this.#amp.gain.setTargetAtTime(1.0, t, 0.001);
		this.#amp.gain.setTargetAtTime(0.0, t + 0.1, 0.1);
	}

	static create(ctx) {
		const osc = ctx.createOscillator();
		const amp = ctx.createGain();
		amp.gain.value = 0.0;

		osc.connect(amp);
		amp.connect(ctx.destination);
		osc.start();

		return new Ping(ctx, osc, amp);
	}
}

class Tuner {
	onPitchAvailable;
	onBinsAvailable;
	#ctx;
	#worklet;
	#bins = new Array(16).fill(0.0);
	#onMessage;
	#isEnabled = true;

	constructor(ctx, worklet) {
		this.#ctx = ctx;
		this.#worklet = worklet;

		worklet.port.start();
		worklet.port.addEventListener('message', e => {
			if (!this.#isEnabled) {
				return;
			}

			switch (e.data.kind) {
				case 'pitch':
					this.onPitchAvailable?.(e.data.value);
					break;

				case 'bin':
					this.#bins.shift();
					this.#bins.push(e.data.value);
					this.onBinsAvailable?.(this.#bins);
					break;
			}
		});
	}

	setEnabled(value) {
		this.#isEnabled = value;
		this.#worklet.port.postMessage({
			kind: 'enable',
			value: value
		});
	}

	destroy() {
		this.#ctx.close();
	}

	static async create(ctx) {
		await ctx.audioWorklet.addModule('./pitch-detect.js');
		const worklet = new AudioWorkletNode(ctx, 'pitch-detect', {
			channelCount: 1,
			channelCountMode: 'explicit',
			numberOfInputs: 1,
			numberOfOutputs: 0
		});

		const stream = await navigator.mediaDevices.getUserMedia({
			video: false,
			audio: {
				autoGainControl: false,
				echoCancellation: false,
				noiseSuppression: false
			}
		});

		const inputNode = ctx.createMediaStreamSource(stream);
		inputNode.connect(worklet);

		return new Tuner(ctx, worklet);
	}
}

class CanvasRenderer {
	width = 0;
	height = 0;
	options;
	#wrapper;
	#canvas;
	#ctx;
	#frame;
	#onRender;

	constructor(wrapper, canvas, ctx, options) {
		this.options = options;
		this.#wrapper = wrapper;
		this.#canvas = canvas;
		this.#ctx = ctx;
		this.#onRender = time => {
			this.#frame = undefined;
			if (this.width === 0 && this.height === 0) {
				this.updateLayout();
			}

			ctx.save();
			this.clear();
			ctx.translate(0.5, 0.5);
			this.render?.(ctx, time);
			ctx.restore();
		}
	}

	clear() {
		this.#ctx.clearRect(0, 0, this.width, this.height);
		if (this.#frame) {
			cancelAnimationFrame(this.#frame);
			this.#frame = undefined;
		}
	}

	updateLayout() {
		const box = this.#wrapper.getBoundingClientRect();
		this.width = Math.floor(box.width * devicePixelRatio);
		this.height = Math.floor(box.height * devicePixelRatio);

		this.#canvas.width = this.width;
		this.#canvas.height = this.height;
		this.#canvas.style.width = `${box.width}px`;
		this.#canvas.style.height = `${box.height}px`;
	}

	scheduleFrame() {
		this.#frame ??= requestAnimationFrame(this.#onRender);
	}

	static create(Handler, wrapperSelector, options = {}) {
		const wrapper = document.querySelector(wrapperSelector);
		const canvas = wrapper.firstElementChild;
		const ctx = canvas.getContext('2d');
		return new Handler(wrapper, canvas, ctx, options);
	}
}

class TuneChart extends CanvasRenderer {
	#current = 0;
	#target = 0;

	update(freq, tuning) {
		const midi = Math.round(Convert.frequencyToMidi(freq, tuning));
		const nearest = Convert.midiToFrequency(midi, tuning);

		this.#target = (freq - nearest) / (
			freq < nearest
				? nearest - Convert.midiToFrequency(midi - 1, tuning)
				: Convert.midiToFrequency(midi + 1, tuning) - nearest
			);

		this.scheduleFrame();
	}

	render(ctx) {
		const padding = 4.0 * devicePixelRatio;
		const line = 1.0 * devicePixelRatio;
		const r2 = 6.0 * devicePixelRatio;
		const r3 = 4.0 * devicePixelRatio;

		ctx.lineWidth = 1.0 * devicePixelRatio;
		ctx.strokeStyle =
		ctx.fillStyle = this.options.color;

		const p0 = { x: padding, y: this.height };
		const p1 = { x: this.width / 2, y: r2 + line + padding };
		const p2 = { x: this.width - padding, y: this.height };

		const offset = p1.x ** 2 + p2.y ** 2;
		const bc = (p0.x ** 2 + p0.y ** 2 - offset) * 0.5;
		const cd = (offset - p2.x ** 2 - p2.y ** 2) * 0.5;
		const det = (p0.x - p1.x) * (p1.y - p2.y) - (p1.x - p2.x) * (p0.y - p1.y);
		const cx = (bc * (p1.y - p2.y) - cd * (p0.y - p1.y)) / det;
		const cy = (cd * (p0.x - p1.x) - bc * (p1.x - p2.x)) / det;
		const r1 = Math.sqrt((p2.x - cx) ** 2 + (p2.y - cy) ** 2);
		const alpha = Math.asin(1.0 - (this.height - p1.y) / r1);

		ctx.beginPath();
		ctx.arc(cx, cy, r1, Math.PI - alpha, alpha, false);
		ctx.stroke();

		ctx.clearRect(cx - r2, cy - r1 - r2, 2.0 * r2, 2.0 * r2);

		ctx.beginPath();
		ctx.arc(cx, cy - r1, r2, 0, 2.0 * Math.PI, false);
		ctx.stroke();

		const delta = this.#target - this.#current;
		this.#current += delta * 0.1;
		if (Math.abs(delta) > Number.EPSILON) {
			this.scheduleFrame();
		}
		else {
			this.#current = this.#target;
		}

		const beta = Math.PI / 2 - (Math.PI / 2 - alpha) * this.#current;

		ctx.beginPath();
		ctx.arc(cx + Math.cos(beta) * r1, cy - Math.sin(beta) * r1, r3, 0, 2.0 * Math.PI);
		ctx.fill();
	}
}

class BinChart extends CanvasRenderer {
	#bins;

	update(bins) {
		this.#bins = bins;
		this.scheduleFrame();
	}

	render(ctx) {
		const bins = this.#bins;
		const wStep = this.width / bins.length;
		const wBin = wStep - 1.0 * devicePixelRatio;
		const radius = wBin / 2;
		const y = Math.floor(this.height / 2);
		const h = y - radius - 1.0 * devicePixelRatio;

		ctx.fillStyle = this.options.color;

		for (let i = 0; i < bins.length; ++i) {
			const xs = i * wStep;
			const xm = xs + radius;
			const xe = xs + wBin;
			const p = bins[i] * h;

			ctx.beginPath();
			ctx.moveTo(xs, y);

			ctx.arcTo(xs, y - p - radius, xm, y - p - radius, radius);
			ctx.arcTo(xe, y - p - radius, xe, y             , radius);

			ctx.arcTo(xe, y + p + radius, xm, y + p + radius, radius);
			ctx.arcTo(xs, y + p + radius, xs, y             , radius);

			ctx.closePath();
			ctx.fill();
		}
	}
}

class ShineEffect {
	#onPointerMove;

	constructor(targets) {
		let frame;
		let mouseX;
		let mouseY;

		const onUpdateGradients = () => {
			frame = undefined;
			for (const target of targets) {
				const box = target.getBoundingClientRect();
				target.style.setProperty('--fx-offset-x', `${100.0 * (mouseX - box.left) / box.width}%`);
				target.style.setProperty('--fx-offset-y', `${100.0 * (mouseY - box.top) / box.height}%`);
			}
		};

		this.#onPointerMove = e => {
			if (e.pointerType === 'mouse') {
				mouseX = e.clientX;
				mouseY = e.clientY;
				frame ??= requestAnimationFrame(onUpdateGradients);
			}
		};

		window.addEventListener('pointermove', this.#onPointerMove, { passive: true });
	}

	destroy() {
		window.removeEventListener('pointermove', this.#onPointerMove);
	}

	static create(selector) {
		return new ShineEffect(
			document.querySelectorAll(selector)
		);
	}
}

(() => {
	const RE_INTEGER = /^-?\d+$/;
	const RE_FLOAT = /^-?\d+(?:[.,]\d*)?$/;
	const MIDI_MIN = 21;
	const MIDI_MAX = 127;


	// resources

	ShineEffect.create('.fx-shiny');

	const tuneChart = CanvasRenderer.create(TuneChart, '#tune-chart', { color: '#000' });
	const binChart = CanvasRenderer.create(BinChart, '#bin-chart', { color: 'hsl(0,75%,63%)' });

	tuneChart.update(440.0);


	// manual conversion form

	const midiInput = document.getElementById('midi-input');
	const noteInput = document.getElementById('note-input');
	const freqInput = document.getElementById('freq-input');

	let lastMidi = 69;
	let lastNote = 'A4';
	let lastFreq = 440.0;

	// TODO: allow +/- 1 by up/down arrow keys
	// TODO: restrict allowed characters

	midiInput.addEventListener('focus', onSelectAllContent, false);
	midiInput.addEventListener('input', () => {
		try {
			const input = midiInput.value;
			if (!RE_INTEGER.test(input)) {
				throw new Error('invalid MIDI number');
			}

			const midi = clampMidi(Number(input));
			const freq = Convert.midiToFrequency(midi);

			clearErrors();
			lastMidi = midi;
			setNote(Convert.midiToNote(midi));
			setFrequency(freq);
			tuneChart.update(freq);
		}
		catch (ex) {
			setError(midiInput, ex.message);
		}
	});

	noteInput.addEventListener('focus', onSelectAllContent, false);
	noteInput.addEventListener('input', () => {
		try {
			const note = noteInput.value;
			const midi = clampMidi(Convert.noteToMidi(note));
			const freq = Convert.midiToFrequency(midi);
			lastFreq = freq;

			clearErrors();
			setMidi(midi);
			lastNote = note;
			setFrequency(freq);
			tuneChart.update(freq);
		}
		catch (ex) {
			setError(noteInput, ex.message);
		}
	});

	freqInput.addEventListener('focus', onSelectAllContent, false);
	freqInput.addEventListener('input', () => {
		try {
			const input = freqInput.value;
			if (!RE_FLOAT.test(input)) {
				throw new Error('invalid frequency value');
			}

			const freq = Number(input.replace(',', '.'));
			const midi = clampMidi(Convert.frequencyToMidi(freq));
			const isRounded = isMidiRounded(midi, freq);

			clearErrors();
			setMidi(midi, isRounded);
			setNote(Convert.midiToNote(midi), isRounded);
			lastFreq = freq;
			tuneChart.update(freq);
		}
		catch (ex) {
			setError(freqInput, ex.message);
		}
	});

	function onSelectAllContent() {
		this.setSelectionRange(0, this.value.length);
	}

	function clearErrors(parent = document) {
		parent
			.querySelectorAll('.input-wrapper__error')
			.forEach(node => {
				node.parentNode.removeChild(node);
			});
	}

	function setError(inputNode, text) {
		const parent = inputNode.parentNode;
		clearErrors(parent);
		const node = document.createElement('span');
		node.classList.add('input-wrapper__error');
		node.textContent = text;
		parent.insertBefore(node, parent.firstChild);
	}

	function clampMidi(midi) {
		const rounded = Math.round(midi);
		if (rounded < MIDI_MIN) {
			throw new Error('value too low');
		}

		if (rounded > MIDI_MAX) {
			throw new Error('value too high');
		}

		return rounded;
	}

	function setMidi(midi, isRounded = false) {
		lastMidi = midi;
		midiInput.value = (isRounded ? '~ ' : '') + midi.toFixed(0);
	}

	function setNote(note, isRounded = false) {
		lastNote = note;
		noteInput.value = (isRounded ? '~ ' : '') + note;
	}

	function setFrequency(freq, precision = 2) {
		lastFreq = freq;
		freqInput.value = freq.toFixed(precision);
	}

	function isMidiRounded(midi, freq) {
		return Math.abs(Convert.midiToFrequency(midi) - freq) > 0.1;
	}

	function setDisabled(disabled) {
		midiInput.disabled =
		noteInput.disabled =
		freqInput.disabled = disabled;
	}


	// extra functions

	const recordButton = document.getElementById('record-button');
	const pingButton = document.getElementById('ping-button');

	let tuner;
	let isTunerActive = false;
	recordButton.addEventListener('click', async () => {
		if (!tuner) {
			tuner = await Tuner.create(getAudioContext());
			tuner.onBinsAvailable = onBinsAvailable;
			tuner.onPitchAvailable = onPitchAvailable;
		}

		isTunerActive = !isTunerActive;
		tuner.setEnabled(isTunerActive);
		setDisabled(isTunerActive);
		recordButton.classList.toggle('button--active', isTunerActive);
		if (!isTunerActive) {
			binChart.clear();
		}
	});

	let ping;
	pingButton.addEventListener('click', () => {
		ping ??= Ping.create(getAudioContext());
		ping.emit(lastFreq);
	});

	function onBinsAvailable(bins) {
		binChart.update(bins);
	}

	function onPitchAvailable(freq) {
		const midi = Math.round(Convert.frequencyToMidi(freq));
		if (midi < MIDI_MIN || midi > MIDI_MAX) {
			return;
		}

		const isRounded = isMidiRounded(midi, freq);

		clearErrors();
		setMidi(midi, isRounded);
		setNote(Convert.midiToNote(midi), isRounded);
		setFrequency(freq, 0);
		tuneChart.update(freq);
	}

	let audioContext;
	function getAudioContext() {
		return audioContext ??= new AudioContext();
	}

})();

	</script>
</html>
